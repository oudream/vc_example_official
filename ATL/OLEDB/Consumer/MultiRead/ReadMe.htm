<!--TO READ THIS HELP FILE, RIGHT-CLICK ON THE FILE NAME IN THE
    SOLUTION EXPLORER PANE AND SELECT "VIEW IN BROWSER"-->

<html><head><title>MultiRead Sample: Reads Database Table Using Multiple Threads</title></head><body><h1>MultiRead Sample: Reads Database Table Using Multiple Threads</h1><div id="mainSection"><div id="mainBody"><div id="allHistory" class="saveHistory" onsave="saveAll()" onload="loadAll()"></div><p /><p>The MultiRead sample demonstrates how to use the OLE DB Consumer Templates classes to read through a table in a database using multiple threads. </p><p>The MultiRead attributes sample is the attributed version of this sample.</p><div class="alert"><table width="100%" cellspacing="0" cellpadding="0"><tr><th align="left">Security Note </th></tr><tr><td><p>This sample code is provided to illustrate a concept and should not be used in applications or Web sites, as it may not illustrate the safest coding practices.</p></td></tr></table></div><h1 class="heading">Building and Running the Sample</h1><div id="sectionSection0" class="seeAlsoNoToggleSection"><h4 class="subHeading">To build and run this sample</h4><div class="subSection"><ol><li><p>Open the solution file MultiRead.sln.</p></li><li><p>From the <b>Build</b> menu, click <b>Build</b>.</p></li><li><p>From the <b>Debug</b> menu, click <b>Start Without Debugging</b>.</p></li><li><p>A Multi-Threaded Read dialog box will appear, prompting you to specify the number of threads to use to read through the table. Click <b>Run</b>.</p></li><li><p>The result will appear as text in the Multi-Threaded Read dialog box, for example, <code>15 records in 7 ms</code>.</p></li></ol></div></div><h1 class="heading">How the Sample Works</h1><div id="sectionSection1" class="seeAlsoNoToggleSection"><p>The sample contains the <code>CMultiDlg</code> class, which is used to show a dialog box. With this dialog box, the user enters the number of threads to use to read through the table. When the user clicks the <b>Run</b> button, <code>ReadRecords</code> in DBRead.h is called to open the database, the session, and the table, and to create the necessary number of threads. As it opens the table, the function sets the <b>DBPROP_CANHOLDROWS</b> property to true so that the provider allows the user to retrieve new rows without releasing the previously retrieved rows. This capability is required, because multiple threads retrieve new rows as other threads are still processing their current threads.</p><p>The sample also shows how to extend the standard <b>CRowset</b> class by creating a new <code>CMyRowset</code> class, which derives from <b>CRowset</b>, and adds the <code>MoveAndProcess</code> member function. The start routine of each thread is the <code>ReadTable</code> function, and the table class is passed to this function. The function calls the routine <code>MoveAndProcess</code> to read through each record. Note that the accessor class <code>CProduct</code> is defined so that the data will not be retrieved automatically on the <code>MoveNext</code> call. This avoids buffer conflicts with the other threads, and there is no need to protect <code>MoveNext</code> with a critical section. The <code>MoveAndProcess</code> function calls <code>MoveNext</code>, and then calls <code>GetDataHere</code> to place the data directly into a local variable of that function. <code>ProcessRecord</code> is called for each record retrieved, and the function simply traces out the values of the record by default.</p><p>Each thread counts the number of records it reads, and those are traced out at the end, along with a total and time taken, which is displayed on the dialog box.</p><div class="alert"><table width="100%" cellspacing="0" cellpadding="0"><tr><th align="left">Note </th></tr><tr><td><p>   The MultiRead sample reads the MultiRead.mdb database file. The sample code assumes that this file is located in the current directory.</p></td></tr></table></div></div><h1 class="heading">Keywords</h1><div id="sectionSection2" class="seeAlsoNoToggleSection"><p>The sample demonstrates the following classes:</p><p>CAccessor, CDataSource, CDBPropSet, CRowset, CSession, CTable </p><p>The sample demonstrates the following macros:</p><p>BEGIN_ACCESSOR_MAP, BEGIN_ACCESSOR, COLUMN_ENTRY, END_ACCESSOR, END_ACCESSOR_MAP, DEFINE_COMMAND </p><p>The sample demonstrates the following functions:</p><p>CreateThread, GetCurrentThreadId, GetExitCodeThread, WaitForMultipleObjects </p><div class="alert"><table width="100%" cellspacing="0" cellpadding="0"><tr><th align="left">Note </th></tr><tr><td><p>Some of the samples, such as this one, have not been modified to reflect the changes in the Visual C++ wizards, libraries, and compiler, but still demonstrate how to complete your desired task.</p></td></tr></table></div></div></div><div id="footer"><div class="footerLine"></div>
          © Microsoft Corporation. All rights reserved.  Send <a href="mailto:DevDocs@microsoft.com?subject=Documentation Feedback :MultiRead Sample: Reads Database Table Using Multiple Threads">comments</a> about this topic to Microsoft.
      </div></div></body></html>
