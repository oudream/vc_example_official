<!--TO READ THIS HELP FILE, RIGHT-CLICK ON THE FILE NAME IN THE
    SOLUTION EXPLORER PANE AND SELECT "VIEW IN BROWSER"-->

<html><head><title>MTMDI Sample: Demonstrates an MFC User Interface Thread</title></head><body><h1>MTMDI Sample: Demonstrates an MFC User Interface Thread</h1><div id="mainSection"><div id="mainBody"><div id="allHistory" class="saveHistory" onsave="saveAll()" onload="loadAll()"></div><p /><p>The MTMDI sample illustrates an MFC user interface thread where user interface events are processed in a separate thread from the main application thread. This sample is a modified version of the single-thread MDI sample. </p><p>MTMDI does not claim a strong rationale for putting the bouncing ball window in a separate thread. A user would not be able to detect the difference between the MDI and MTMDI samples on a single-processor computer. Even on a multiprocessor computer, the user would not be able to detect the difference, given that the ball movement is based on a window timer.</p><p>Nevertheless, MTMDI does illustrate techniques for implementing an MFC user interface thread. Compare the sources for the MDI and MTMDI samples to study the programming overhead associated with using MFC user interface threads.</p><p>The programming overhead in MTMDI should be a warning that you should have a good reason for using a user interface thread to justify the programming cost. The much more common type of thread in MFC is the worker thread, illustrated by the MTRECALC sample.</p><div class="alert"><table width="100%" cellspacing="0" cellpadding="0"><tr><th align="left">Security Note </th></tr><tr><td><p>This sample code is provided to illustrate a concept and should not be used in applications or Web sites, as it may not illustrate the safest coding practices.</p></td></tr></table></div><h1 class="heading">Building and Running the Sample</h1><div id="sectionSection0" class="seeAlsoNoToggleSection"><h4 class="subHeading">To build and run the MTMDI sample</h4><div class="subSection"><ol><li><p>Open the solution MtMdi.sln. </p></li><li><p>On the <b>Build</b> menu, click <b>Build</b>. </p></li><li><p>On the <b>Debug</b> menu, click <b>Start Without Debugging</b>. </p></li></ol></div><p>The user interface for MTMDI is similar to the user interface of the <MSHelp:link keywords="8536E5BB-52D9-4B2D-9091-A1C526240670" tabindex="0" >MTGDI</MSHelp:link> sample. However, MTMDI includes one additional user interface feature: you can click anywhere in the bounce window to change the position of the moving ball immediately.</p><p>You can use the <b>File</b> menu to create new windows of two different types. Once the windows are created, the application will let you change the attributes of the items in the window by using commands in one of these menus: <b>Color</b>, <b>Speed</b>, <b>Window</b>, and <b>Help</b>. Note that the "Hello!" windows do not have a <b>Speed</b> menu.</p><p>MTMDI makes use of its own <b>CWinThread</b>-derived class, called <code>CBounceThread</code>. <code>CBounceThread</code> is implemented in the Mtbounce.cpp file. The thread contains all the painting and timing code that the bouncing ball window needs to animate the ball in the window.</p><p>The application creates each thread just as the MDI child window is created. This happens in the <code>CBounceMDIChildWnd::Create</code> function, found in Bounce.cpp. This function creates both the window and the thread, associating the thread to the window.</p><p>Whenever you close a bounce window, the associated thread is automatically destroyed. The "Hello!" windows do not have a thread of their own; their messages are handled by the application's primary thread.</p></div><h1 class="heading">Keywords</h1><div id="sectionSection1" class="seeAlsoNoToggleSection"><p>This sample demonstrates the following keywords:</p><p>AfxGetInstanceHandle; AfxMessageBox; AfxRegisterWndClass; CBitmap::CreateCompatibleBitmap; CCmdTarget::OnCmdMsg; CCmdUI::SetCheck; CColorDialog::DoModal; CColorDialog::GetColor; CDC::BitBlt; CDC::CreateCompatibleDC; CDC::DeleteDC; CDC::DrawText; CDC::Ellipse; CDC::FillRect; CDC::GetDeviceCaps; CDC::SelectObject; CDC::SetBkColor; CDC::SetTextColor; CFrameWnd::LoadFrame; CFrameWnd::rectDefault; CGdiObject::DeleteObject; CMDIChildWnd::Create; CMenu::LoadMenu; CRect::Height; CRect::Width; CWinApp::ExitInstance; CWinApp::InitInstance; CWnd::Create; CWnd::DestroyWindow; CWnd::GetClientRect; CWnd::GetCurrentMessage; CWnd::GetDC; CWnd::GetDlgItem; CWnd::GetWindow; CWnd::Invalidate; CWnd::KillTimer; CWnd::MessageBox; CWnd::OnCreate; CWnd::OnDestroy; CWnd::OnLButtonDown; CWnd::OnPaint; CWnd::OnSize; CWnd::OnTimer; CWnd::ReleaseDC; CWnd::SendMessage; CWnd::SetTimer; CWnd::SetWindowPos; CWnd::ShowWindow; CWnd::UpdateWindow; CloseHandle; CreateEvent; CreateThread; EnumChildWindows; GetSysColor; GetVersion; LOWORD; LoadCursor; LoadIcon; LoadMenu; MAKEINTRESOURCE; RGB; SetEvent; Sleep; WaitForSingleObject; max; min</p><div class="alert"><table width="100%" cellspacing="0" cellpadding="0"><tr><th align="left">Note </th></tr><tr><td><p>Some samples, such as this one, have not been modified to reflect the changes in the Visual C++ wizards, libraries, and compiler, but still demonstrate how to complete your desired task. </p></td></tr></table></div></div></div><div id="footer"><div class="footerLine"></div>
          © Microsoft Corporation. All rights reserved.  Send <a href="mailto:DevDocs@microsoft.com?subject=Documentation Feedback :MTMDI Sample: Demonstrates an MFC User Interface Thread">comments</a> about this topic to Microsoft.
      </div></div></body></html>
